#!/usr/bin/env python3
# Daniel B. Stribling
# Renne Lab, University of Florida
# Hybkit Project : http://www.github.com/RenneLab/hybkit

"""
Read one or more '.hyb' format files and analyze the contained hybrid sequences.

Analysis Types:
   
    ========== =========================================================
    ``type``   Assigns types to each segment within hyb records
    ``mirna``  Assigns which segments are a miRNA based on segment types
    ========== =========================================================
"""

import sys
import os 
import argparse
import textwrap
import hybkit

# Import module-level dunder-names:
from hybkit.__about__ import __author__, __contact__, __credits__, __date__, __deprecated__, \
                             __email__, __license__, __maintainer__, __status__, __version__

# Divide docstring into argparse and full portions.
argparse_doc = __doc__ + '\nFor full script description and usage, see the hybkit documentation.'
__doc__ += textwrap.dedent("""
    This utility reads in one or more files in hyb-format (see the :ref:`Hybkit Hyb File Specification`)
    and analyzes hybrid record properties. 

    ``type`` Analysis:
        | The 'type' analysis utilizes the :func:`hybkit.HybRecord.eval_types` method
          to assign the record flags: :ref:`seg1_type <seg1_type>` 
          and :ref:`seg2_type <seg2_type>`

        Example system calls:
            ::
            
                $ hyb_analysis -t type -i my_file_1.hyb

                $ hyb_analysis -t type -i my_file_1.hyb \\
                               --type_method string_match

                $ hyb_analysis -t type -i my_file_1.hyb \\
                               --type_method string_match \\
                               --type_parameters my_parameters_file.csv \\
                               --allow_unknown_seg_types

    ``mirna`` Analysis:
        | The 'mirna' analysis uses the :func:`hybkit.HybRecord.eval_mirna` method
          to identify properties relating to mirna within the hybrids, 
          including mirna presence and positions.
          This analysis requires the seg_type flags to be filled, either by a type analysis,
          or by parsing the read using the ``--hybformat_ref True`` option with a hyb-format
          reference. The :ref:`mirna_seg <mirna_seg>` flag is then set for each record, indicating
          the presence and position of any miRNA within the hybrid.

        Example system calls:
            ::
            
                $ hyb_analysis -t mirna -i my_file_1.hyb

                $ hyb_analysis -t mirna -i my_file_1.hyb \\
                               --mirna_types miRNA kshv-miRNA

        This can also be combined with the type analysis, as such:

                $ hyb_analysis -t type mirna -i my_file_1.hyb \\
                               --type_method string_match \\
                               --type_parameters my_parameters_file.csv \\
                               --allow_unknown_seg_types \\
                               --mirna_types miRNA kshv-miRNA

    """)

__doc__ += hybkit.util.output_description

# Create Command-line Argument Parser
def make_parser():
    script_args = argparse.ArgumentParser(add_help=False)
    parser_components = [
                         hybkit.util.in_hybs_parser,
                         hybkit.util.out_opts_parser,
                         hybkit.util.hyb_analysis_parser,
                         hybkit.util.gen_opts_parser,
                         hybkit.util.hybrecord_parser,
                         hybkit.util.hybfile_parser,
                        ]
    script_parser = argparse.ArgumentParser(
         parents=parser_components,
         description=argparse_doc.replace('|', '').replace('``', ''),
         formatter_class=argparse.ArgumentDefaultsHelpFormatter,
         allow_abbrev=False,
         )

    script_parser.set_defaults(out_suffix=hybkit.settings._ANALYSIS_OUT_SUFFIX)

    return script_parser

# Define main script function.
def hyb_analyze(in_hyb_files, analysis_types, 
                out_dir='.', 
                out_suffix=hybkit.settings._ANALYSIS_OUT_SUFFIX,
                out_hyb_files=None,
                type_method=None, 
                type_params=None,  
                mirna_types=None,
                verbose=False, silent=False):
    """Perform main script function."""

    if not silent:
        print('\nPerforming Analysis of Hyb Files...')
   
    # Set analysis modes
    do_type = ('type' in analysis_types)
    do_mirna = ('mirna' in analysis_types)

    if verbose:
        print('\nPerforming Analysis Types: ' + ', '.join([x.title() for x in analysis_types]))
        print()

    # Prepare for type analysis.
    if do_type:
        if type_method is None:
            message = '"type_method" argument is required for hyb_analysis method.'
            print(message)
            raise Error(message)

        if type_method != make_parser().get_default('type_method'):
            if verbose:
                print('Setting non-default type finding method: %s' % type_method)
            params = {}
            params_method = hybkit.HybRecord.find_type_parameter_methods[type_method]
            if params_method is not None:
                if type_params is None:
                    type_params = (
                        hybkit.HybRecord.find_type_default_parameter_files[type_method])
                    if verbose:
                        print ('Using default type parameter file: %s' % type_params)
                elif verbose:
                    print('Using provided type parameter file: %s' % type_params)
                params = params_method(type_params)
                if verbose:
                    print()
            hybkit.HybRecord.select_find_type_method(type_method, params)

    if do_mirna:
        if not mirna_types:
            message = 'mirna_types required for mirna analysis.'
            print(message)
            raise RuntimeError(message)

        if verbose:
            print('Assigning types as miRNA:')
            print('   ', mirna_types, '\n')

    for i, in_hyb_file in enumerate(in_hyb_files):
        file_basename = os.path.basename(in_hyb_file)
        if out_hyb_files is not None:
            out_hyb_file = out_hyb_files[i]
        else:
            out_hyb_file = hybkit.util.make_out_file_name(in_hyb_file,
                                                          name_suffix=out_suffix,
                                                          in_suffix='.hyb',
                                                          out_suffix='.hyb',
                                                          out_dir=out_dir,
                                                          seg_sep='_',)

        if verbose:
            print('Analyzing File:\n    ' + in_hyb_file)
            print(out_hyb_file)
    
        with hybkit.HybFile.open(in_hyb_file, 'r') as in_hyb,\
             hybkit.HybFile.open(out_hyb_file, 'w') as out_hyb:
            for record in in_hyb:
                if do_type:
                    record.eval_types()
            
                if do_mirna:
                    record.eval_mirna(mirna_types)
     
                out_hyb.write_record(record)

    if verbose:
        print('\nAnalysis Complete.\n')


# Execute the script function
if __name__ == '__main__':
    script_parser = make_parser()
    args = script_parser.parse_args() 
    hybkit.util.validate_args(args, script_parser)
    hybkit.HybRecord.set_namespace_settings(args, verbose=args.verbose)
    hybkit.HybFile.set_namespace_settings(args, verbose=args.verbose)
    hyb_analyze(
                args.in_hyb, 
                args.analysis_types, 
                args.out_dir,
                out_suffix=args.out_suffix,
                out_hyb_files=args.out_hyb,
                type_method=args.type_method,
                type_params=args.type_params,
                mirna_types=args.mirna_types,
                verbose=args.verbose,
                silent=args.silent,
               )

